

// 1byte = 8bit
	2^10 = 4 byte = 32bit
	1024byte = 1kKB
	1bit = 0, 1 이진수, 256가지 경우의 수/ 0~255까지 

	
<자료형 data type>
	: 어떠한 자료를 나타내는지 설명(크기,byte)
	(내가 선언할 메모리 공간에 이름을 부여(변수이름) 크기 형태 부연 설명해주는 역할)

		- 정수형: char(1), short(2), int(4), long(4), long long(8)
		- 실수형: float(4), double(8)

			정수형, 실수형 구분하는 이유: 처리 방식 완전 달라

	

// 정수형
- unsigned char c = 0; // 양의 정수만 0~255까지
			c = 256; 숫자 초과 시, 짤려서 0으로 뜸
			c = -1;  음수 표현 시, 

			8개의 비트 =  0일 때 2^8 + 1일 때 2^8 = 256가지 (인덱스 0부터 카운트) 


	- char = 0; (양수 음수 모두)
	- 	char c = 0; //음수 양수 모두
		c == 0; // 비교연산자 , 동일
		c = 256; 숫자 초과해서 짤림 = 0으로 보임 
		
		- 8개의 비트 =  msb가 0일 때 2^8 (양수로 판단)
	+ msb가 1일 때 2^8 (음수로 판단) = 256가지 (인덱스 0부터 카운트) 

								10 + (-10) =  0
								5 + (-5) = 0 의 접근 방식으로 음수 계산

								0 000 0001	 1
			+			 		1 111 1111	-1
			-----------------------------------
			=	   1(자릿수 아웃) 0 000 0000	 0

		char c1 = 0;		
		c1 = 255; // 8개의 비트가 전부 1로 채워져 1 111 1111 = 음수 관점에서 -1로도 볼 수 있음
					
		c1 = -1; // 255


 음의 정수 찾기 (2의 보수법)
- 대응되는 양수의 부호를 반전 후,+ 1

				0 000 0010      2
		+		1 111 110(1+1) -2  
		--------------------------
		=		1 000 0000		0




//실수형	
	- 실수형: float(4), double(8) 더 정교한 
	- 부동소수점 = 실수

	
	int a = 4 + 4.0; 
		=> 실수 4.0을 정수로 바꾸는 형변환 과정 일어남 



- 정수표현 방식과 실수 표현 방식 다름
- 실수표현 방식은 정밀도에 의존
	따라서 double(8) 자료형이 float(4)보다 더 아래의 소수점까지 정확히 표현 가능

					이런식으로 float f = 1.2415f + (float)20;

- 정수는 정수까리, 실수는 실수끼리 연산하되, 
- 두 표현방식의 피 연산자가 연산도리 경우 명시적으로 변환하자
- 


<연산자>

- 대입연산자  =
- 산술연산자  + - * / %(모듈러스, 나머지) 
	++ --							
	- nt data = 10 + 10;
	// data = data + 20;
			data += 20; // += 더해서 = 마감 꼭 필요


		data = (int)(10. / 3.); 명시적으로 int로 바꾸어서 데이터로 넣겠다
		 
	 1.234f (4바이트)
	 1.234. (8바이트)
- 실수를 상수로 적을 경우 소수점 뒤에 f를 붙이면 float 자료형으로, 
f를 붙이지 않으면 double자료형으로 간주


- 증감 연산자 ++ -- 다음 단계로(한단계 증감)

	data--;
	data++;


<논리 연산자>

- !(역): 반전(참이면 거짓으로)
- &&(And): 양쪽 둘다 참일 때-> 참, 둘 중 하나라도 거짓->거짓
- ||(Or): 둘중 하나, or
- 참true,  거짓false
	- 참: 0이 아닌 모든 수 = 보통은 1